{"pages":[{"title":"","text":"协会简介武汉理工大学电子科技协会成立于2007年,是一个致力于分享竞赛经验、提供竞赛资料的优质学生社团。指导单位为武汉理工大学信息工程学院，学院为协会提供了大量资源。针对于“电子设计大赛”、“蓝桥杯”两项比赛，目前协会在硬件、软件两方面为协会会员提供帮助，据统计，协会目前在包括电子设计大赛等多项个比赛中都取得优异成绩，为广大协会会员提供经验与技术支持！ 联系我们邮箱:whut.electronic@yandex.com 官方QQ：3516446071","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"手把手教你用hexo搭建个人博客","text":"什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。比如我们电子科技协会的官方博客就是用hexo搭建的 话不多说，这就开始我们的建站教程一、安装Git和Node.js1.安装Git版本工具Git是目前世界上较为流行的分布式版本控制系统，使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。下载地址：https://git-scm.com/downloads 2.搭建Node.js环境我们了解到Hexo基于Node.js的，那么我们搭建博客网站首先需要安装Node.js环境。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。下载地址：http://nodejs.cn/download 二、安装hexo在一个你可以找到的地方，新建一个文件夹，路径中不要包含中文，文件夹名就叫myblog吧 然后鼠标右键点击git bash (！！！之后的命令都是在git bash里输入的) 1npm install -g hexo-cli //安装hexo 三、开始了开始了12hexo init 初始化文件夹npm install 安装插件 可能要等上一会儿，安装完，你会发现，你的空文件里多了一些东西 .├── _config.yml 配置信息├── package.json 应用程序信息├── scaffolds 模板信息├── source 资源文件夹| ├── _drafts| └── _posts└── themes 主题文件夹 四、配置开始在 _config.yml 中修改大部分的配置 参数 描述title 网站标题subtitle 网站副标题description 网站描述author 您的名字language 网站使用的语言timezone 网站时区。Hexo 默认使用您电脑的时区。 这是我这部分的配置 五、要开始出效果了123hexo clean 删除公共文件hexo g 生成静态文章hexo s 开始服务 在浏览器中输入 http://localhost:4000 即可看到你的博客 当然这样肯定使不够的，因为你只要一按Ctrl+C,这个端口就访问不了了，你也就看不了你的博客了 六、GitHub（要发挥gayhub的作用啊）GitHub创建个人仓库首先，你先要有一个GitHub账户，去注册一个吧。 注册完登录后，在GitHub.com中看到一个New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。 点击create repository。 生成SSH添加到GitHub回到你的git bash中 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 可以用以下两条，检查一下你有没有输对 12git config user.namegit config user.email 然后创建SSH,一路回车 1ssh-keygen -t rsa -C &quot;youremail&quot; 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。(不在C盘，就在你博客文件的这个文件夹里) ssh，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。 七、将hexo部署到GitHub这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 1npm install hexo-deployer-git --save 然后 123hexo cleanhexo ghexo d //deploy部署文章 注意deploy时可能要你输入username和password。 过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！ 感谢阅读 author:kcqnly","link":"/2019/07/14/手把手教你用hexo搭建个人博客/"},{"title":"基于.Net Core的微型Http服务框架","text":".Net Core是由微软公司开发的一套开源的，具有跨平台能力（Windows，Linux，Mac OSX）的应用程序开发框架。本人最近用.net写了一套简单的Http服务框架，并集成了MySql数据库，写此博文作为分享，也为了防止自己遗忘。本文适合了解Http协议的原理，以及面向对象程序设计各种概念的读者。 服务的组织架构一个Http服务器会负责多个Http服务，即一个Http服务器存在多个接口，这些接口的业务应互不干扰。而每个接口的业务都涉及数据的处理、数据库的读写等操作。因此考虑将每个服务分为控制层(Controller)和数据层(Model)。控制层负责服务逻辑的控制，数据层负责数据的操作。同时，服务因该具有高度的可拓展性，即新服务的加入应该是便捷的。因此应该有一个服务管理器，能够动态添加或删除服务。为了方便，我们将每个服务都称之为应用（Application）。在这种架构中，所有Http请求应携带应用标识符，以方便服务端区分请求的是哪一个应用。服务端接收Http请求后，通过标识符将请求参数下发给相应的应用，应用处理结束后，将要返回的数据通知给Http服务器，然后服务器回应数据，这样便完成了一次Http请求的处理。综合以上分析，所有的应用都应继承自以下接口：12345interface IApplication{ string Name { get; } HttpResponseArgs Handle(HttpArgs args);} 其中，Name属性是唯一的，即这个应用的名称，用来区分不同的应用；Handle为该Application的处理逻辑。HttpArgs是Http请求参数，HttpResponseArgs是Http响应参数，将请求参数传递给对应的Application后，要求其返回一个HttpResponseArgs，用来对请求进行回应。这样一来，不同的应用即为不同的类，他们都实现IApplication这个接口。因此，添加一个应用，只需添加一个该应用的实例即可。123456789101112131415161718192021222324252627282930313233class Application { static Dictionary&lt;string, Type&gt; appTypes = new Dictionary&lt;string, Type&gt;(); static string appKey = \"app\"; public static bool LoadApp(Type appType) { if (!typeof(IApplication).IsAssignableFrom(appType)) return false; var construct = appType.GetConstructor(new Type[0]); var app = (IApplication)construct.Invoke(null); if (appTypes.ContainsKey(app.Name)) return false; appTypes.Add(app.Name, appType); return true; } public static bool UnloadApp(string appName) { if (appTypes.ContainsKey(appName)) appTypes.Remove(appName); else return false; return true; } public static void SetAppKeyString(string keystr = \"app\") { appKey = keystr; } public static HttpResponseArgs Handle(HttpArgs args) { if (!appTypes.ContainsKey(args.GetArgValue(appKey))) return null; var construct = appTypes[args.GetArgValue(appKey)].GetConstructor(new Type[0]); var app = (IApplication)construct.Invoke(null); return app.Handle(args); } } appTypes字典用于存放应用类型，与应用的Name相对应。LoadApp方法用来加载一个应用，对应用进行去重判断以后获取一个该应用的实例，并添加到字典中；UnloadApp方法用来卸载一个应用，与LoadApp相对应。SetAppKeyString用来设置http请求参数中区别不同app的参数键，默认为”app”。Handle用于接收Http请求参数后向对应的app进行下发，获取到app处理后的返回参数后返回给Http服务器。 数据操作层服务端的每个app都会涉及到数据操作。不同的app的数据会有很大的区别，但是很多数据操作，比如对数据库的增删查改，都是类似的。因此考虑创建一个基类，其中包含通用的数据处理和数据库操作方法，然后所有应用的数据层都继承自这个类。（下列代码均为具体实现，不必仔细阅读）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265class BaseModel { /// &lt;summary&gt; /// 数据表名 /// &lt;/summary&gt; protected virtual string TableName { get; } /// &lt;summary&gt; /// 判断数据表中是否存在指定数据 /// &lt;/summary&gt; /// &lt;param name=\"limit\"&gt;查找条件&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool Find(Dictionary&lt;string, object&gt; limit) { var conn = DataBase.GetConnection(); conn.Open(); var findstr = string.Format(\"select * from {0} where\", TableName); StringBuilder sb = new StringBuilder(findstr); foreach (var kv in limit) { var key = kv.Key; if ((!\"&lt;&gt;=\".Contains(key.TrimEnd(' ').Last())) &amp;&amp; (!key.ToUpper().Contains(\" LIKE\"))) key += '='; sb.AppendFormat(\" {0}'{1}' and\", key, kv.Value); } sb.Remove(sb.Length - 3, 3); findstr = sb.ToString(); MySqlCommand cmd = new MySqlCommand(findstr, conn); MySqlDataReader reader = cmd.ExecuteReader(); var result = false; if (reader.Read()) result = true; conn.Close(); return result; } /// &lt;summary&gt; /// 判断数据表中是否存在指定数据 /// &lt;/summary&gt; /// &lt;param name=\"key\"&gt;查找键&lt;/param&gt; /// &lt;param name=\"value\"&gt;查找值&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool Find(string key, string value) { var conn = DataBase.GetConnection(); conn.Open(); var findstr = string.Format(\"select * from {0} where {1}='{2}'\", TableName, key, value); MySqlCommand cmd = new MySqlCommand(findstr, conn); MySqlDataReader reader = cmd.ExecuteReader(); var result = false; if (reader.Read()) result = true; conn.Close(); return result; } /// &lt;summary&gt; /// 从数据表中获取指定数据 /// &lt;/summary&gt; /// &lt;param name=\"key\"&gt;查找键&lt;/param&gt; /// &lt;param name=\"value\"&gt;查找值&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public List&lt;Dictionary&lt;string, object&gt;&gt; Select(string key, string value) { List&lt;Dictionary&lt;string, object&gt;&gt; result = new List&lt;Dictionary&lt;string, object&gt;&gt;(); var conn = DataBase.GetConnection(); conn.Open(); var restric = new string[4]; restric[2] = TableName; var table = conn.GetSchema(\"Columns\", restric); List&lt;string&gt; colums = new List&lt;string&gt;(); foreach (DataRow r in table.Rows) { colums.Add(r[\"column_name\"].ToString()); } var findstr = string.Format(\"select * from {0} where {1}='{2}'\", TableName, key, value); MySqlCommand cmd = new MySqlCommand(findstr, conn); MySqlDataReader reader = cmd.ExecuteReader(); while (reader.Read()) { Dictionary&lt;string, object&gt; dt = new Dictionary&lt;string, object&gt;(); foreach (var cn in colums) { dt.Add(cn, reader[cn]); } result.Add(dt); } reader.Dispose(); cmd.Dispose(); conn.Close(); return result; } /// &lt;summary&gt; /// 从数据表中获取指定数据 /// &lt;/summary&gt; /// &lt;param name=\"limit\"&gt;查找条件&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public List&lt;Dictionary&lt;string, object&gt;&gt; Select(Dictionary&lt;string, object&gt; limit) { List&lt;Dictionary&lt;string, object&gt;&gt; result = new List&lt;Dictionary&lt;string, object&gt;&gt;(); var conn = DataBase.GetConnection(); conn.Open(); var restric = new string[4]; restric[2] = TableName; var table = conn.GetSchema(\"Columns\", restric); List&lt;string&gt; colums = new List&lt;string&gt;(); foreach (DataRow r in table.Rows) { colums.Add(r[\"column_name\"].ToString()); } var udstr = string.Format(\"select * from {0} where\", TableName); StringBuilder sb = new StringBuilder(udstr); foreach (var kv in limit) { var key = kv.Key; if ((!\"&lt;&gt;=\".Contains(key.TrimEnd(' ').Last())) &amp;&amp; (!key.ToUpper().Contains(\" LIKE\"))) key += '='; sb.AppendFormat(\" {0}'{1}' and\", key, kv.Value); } sb.Remove(sb.Length - 3, 3); udstr = sb.ToString(); MySqlCommand cmd = new MySqlCommand(udstr, conn); MySqlDataReader reader = cmd.ExecuteReader(); while (reader.Read()) { Dictionary&lt;string, object&gt; dt = new Dictionary&lt;string, object&gt;(); foreach (var cn in colums) { dt.Add(cn, reader[cn]); } result.Add(dt); } reader.Dispose(); return result; } /// &lt;summary&gt; /// 将数据插入到数据表 /// &lt;/summary&gt; /// &lt;param name=\"data\"&gt;要插入的数据&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool Insert(Dictionary&lt;string, object&gt; data) { return InsertGetID(data) == -1 ? false : true; } /// &lt;summary&gt; /// 将数据插入到数据表，并得到当前自增数 /// &lt;/summary&gt; /// &lt;param name=\"data\"&gt;要插入的数据&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public long InsertGetID(Dictionary&lt;string, object&gt; data) { var connection = DataBase.GetConnection(); connection.Open(); StringBuilder sb = new StringBuilder(); sb.Append(\"insert into \"); sb.Append(TableName + \" set \"); foreach (var c in data) { sb.Append(c.Key + \"=\"); sb.Append(\"'\" + c.Value + \"' ,\"); } sb.Remove(sb.Length - 1, 1); MySqlCommand cmd = new MySqlCommand(sb.ToString(), connection); cmd.ExecuteNonQuery(); long result = cmd.LastInsertedId; cmd.Dispose(); connection.Close(); return result; } /// &lt;summary&gt; /// 从数据表中删除符合条件的数据 /// &lt;/summary&gt; /// &lt;param name=\"limit\"&gt;查找条件&lt;/param&gt; /// &lt;returns&gt;受影响的数据的数量&lt;/returns&gt; public long Delete(Dictionary&lt;string, object&gt; limit) { //返回删除的数据条数 var conn = DataBase.GetConnection(); conn.Open(); var delstr = string.Format(\"delect from {0} where\", TableName); StringBuilder sb = new StringBuilder(delstr); foreach (var kv in limit) { var key = kv.Key; if ((!\"&lt;&gt;=\".Contains(key.TrimEnd(' ').Last())) &amp;&amp; (!key.ToUpper().Contains(\" LIKE\"))) key += '='; sb.AppendFormat(\" {0}'{1}' and\", key, kv.Value); } sb.Remove(sb.Length - 3, 3); delstr = sb.ToString(); MySqlCommand cmd = new MySqlCommand(delstr, conn); long result = cmd.ExecuteNonQuery(); cmd.Dispose(); conn.Close(); return result; } /// &lt;summary&gt; /// 从数据表中删除符合条件的数据 /// &lt;/summary&gt; /// &lt;param name=\"key\"&gt;查找键&lt;/param&gt; /// &lt;param name=\"value\"&gt;查找值&lt;/param&gt; /// &lt;returns&gt;受影响的数据的数量&lt;/returns&gt; public int Delete(string key, string value) { //返回删除的数据条数 var conn = DataBase.GetConnection(); conn.Open(); var findstr = string.Format(\"delete from {0} where {1}='{2}'\", TableName, key, value); MySqlCommand cmd = new MySqlCommand(findstr, conn); var result = cmd.ExecuteNonQuery(); cmd.Dispose(); conn.Close(); return result; } /// &lt;summary&gt; /// 更新数据表中的数据 /// &lt;/summary&gt; /// &lt;param name=\"key\"&gt;查找键&lt;/param&gt; /// &lt;param name=\"value\"&gt;查找值&lt;/param&gt; /// &lt;param name=\"newdata\"&gt;新数据&lt;/param&gt; /// &lt;returns&gt;受影响的数据数量&lt;/returns&gt; public long Update(string key, string value, Dictionary&lt;string, object&gt; newdata) { string udstr = string.Format(\"update {0} set \", TableName); StringBuilder sb = new StringBuilder(udstr); foreach (var u in newdata) { sb.AppendFormat(\"{0} = '{1}',\", u.Key, u.Value); } sb.Remove(sb.Length - 1, 1); sb.AppendFormat(\" where {0} = '{1}'\", key, value); udstr = sb.ToString(); var conn = DataBase.GetConnection(); conn.Open(); MySqlCommand cmd = new MySqlCommand(udstr, conn); long result = cmd.ExecuteNonQuery(); cmd.Dispose(); conn.Close(); return result; } /// &lt;summary&gt; /// 更新数据表中的数据 /// &lt;/summary&gt; /// &lt;param name=\"limit\"&gt;查找条件&lt;/param&gt; /// &lt;param name=\"newdata\"&gt;新数据&lt;/param&gt; /// &lt;returns&gt;受影响的数据的数量&lt;/returns&gt; public long Update(Dictionary&lt;string, object&gt; limit, Dictionary&lt;string, object&gt; newdata) { string udstr = string.Format(\"update {0} set \", TableName); StringBuilder sb = new StringBuilder(udstr); foreach (var u in newdata) { sb.AppendFormat(\"{0} = '{1}',\", u.Key, u.Value); } sb.Remove(sb.Length - 1, 1); sb.Append(\" where \"); foreach (var kv in limit) { var key = kv.Key; if ((!\"&lt;&gt;=\".Contains(key.TrimEnd(' ').Last())) &amp;&amp; (!key.ToUpper().Contains(\" LIKE\"))) key += '='; sb.AppendFormat(\" {0}'{1}' and\", key, kv.Value); } sb.Remove(sb.Length - 3, 3); udstr = sb.ToString(); var conn = DataBase.GetConnection(); conn.Open(); MySqlCommand cmd = new MySqlCommand(udstr, conn); long result = cmd.ExecuteNonQuery(); cmd.Dispose(); conn.Close(); return result; } } 在这个类当中包含了对数据库进行增删查改的通用操作。不同的应用所操作的数据表可能不同，因此数据表名定义为可覆写的类型。同时也考虑到，不同的应用操作的都是同一个数据库，因此应该有一个类负责管理数据库的配置和连接。1234567891011121314151617181920212223242526272829303132333435363738394041424344class DataBase { /// &lt;summary&gt; /// 数据库名 /// &lt;/summary&gt; private static string Name { get; set; } = \"test\"; /// &lt;summary&gt; /// 数据库地址 /// &lt;/summary&gt; private static string Host { get; set; } = \"127.0.0.1\"; /// &lt;summary&gt; /// 数据库端口 /// &lt;/summary&gt; private static int Port { get; set; } = 3306; /// &lt;summary&gt; /// 用户名 /// &lt;/summary&gt; private static string UserName { get; set; } = \"root\"; /// &lt;summary&gt; /// 密码 /// &lt;/summary&gt; private static string PassWord { get; set; } = \"root\"; private static string ConnStr { get; set; } public static MySqlConnection GetConnection() { if (ConnStr == null) throw new Exception(\"数据库未初始化\"); else return new MySqlConnection(ConnStr); } public static void Initialise(string name, string host, int port, string user, string password) { ConnStr = string.Format( \"Database = {0}; datasource = {1}; port = {2}; user={3};pwd={4};SslMode = none; charset=utf8;\" , name, host, port, user, password); } public static void Initialise() { if (Name == null || Host == null || UserName == null || PassWord == null) return; Initialise(Name, Host, Port, UserName, PassWord); } } 数据库的连接及配置统一由这个类进行管理，从而避免各应用操作数据库时可能发生的错误和冲突。 Http消息的封装为了方便程序处理，以及架构的清晰，应对Http消息进行封装。首先是Http请求参数：12345678910111213141516171819202122232425262728293031323334353637383940class HttpArgs{ protected Dictionary&lt;string, string&gt; getArgs; protected JObject postArgs_j; /// &lt;summary&gt; /// 创建HttpArgs消息对象 /// &lt;/summary&gt; /// &lt;param name=\"get_args\"&gt;&lt;/param&gt; /// &lt;param name=\"response\"&gt;&lt;/param&gt; public HttpArgs(Dictionary&lt;string, string&gt; get_args, JObject post_args) { getArgs = get_args; postArgs_j = post_args; } /// &lt;summary&gt; /// 获取指定Get参数的值 /// &lt;/summary&gt; /// &lt;param name=\"key\"&gt;参数的键&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetArgValue(string key) { if (getArgs.ContainsKey(key)) { return getArgs[key]; } else { return string.Empty; } } /// &lt;summary&gt; /// 获取Post参数 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public JObject GetPostValue() { if (postArgs_j == null) return new JObject(); return postArgs_j; }} 对于Get方式传递的参数，使用字典进行存放，并提供GetArgValue方法进行查询；对于Post方式传递的参数，封装为JObject对象(这里借助了Newton.json包)，并提供GetPostValue方法，直接返回JObject对象。接下来是Http相应参数的封装：123456789101112131415161718192021222324252627282930313233343536373839class HttpResponseArgs { public ResponseType ResponseType { get; set; } private JObject obj { get; set; } private string rawStr { get; set; } public HttpResponseArgs(JObject obj, ResponseType type) { this.obj = obj; ResponseType = type; } public HttpResponseArgs(string msg) { rawStr = msg; ResponseType = ResponseType.Raw; } public override string ToString() { if (ResponseType == ResponseType.Raw) { return rawStr; } var jstr = obj.ToString(Newtonsoft.Json.Formatting.Indented); switch (ResponseType) { case ResponseType.Json: return jstr; case ResponseType.Xml: return Newtonsoft.Json.JsonConvert.DeserializeXmlNode(jstr).InnerXml; } return jstr; } }enum ResponseType { Json, Xml, Raw } 首先是Http相应的类型。作为服务端接口，常用的返回格式是xml格式或者json格式。为了保持可拓展性，也应留出回应任意文本的接口。对于json格式，利用Newton.Json包将数据对象转换为JObject，从而得到json字符串；对于xml格式，先将数据对象转换为JObject，再转换为xml对象，从而得到xml文本。 按照我们的思路对Http服务器进行封装最后，对原始的Http服务器进行封装，以实现我们思路中的架构：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class HttpServer { private HttpListener httpListener; /// &lt;summary&gt; /// Http请求传递的参数 /// &lt;/summary&gt; /// &lt;param name=\"args\"&gt;&lt;/param&gt; /// &lt;returns&gt;回应参数,无需回应时应返回null&lt;/returns&gt; public delegate HttpResponseArgs HttpGetRequestDelegate(HttpArgs args); public event HttpGetRequestDelegate HttpGotRequest; /// &lt;summary&gt; /// 使用指定端口构造Http服务器 /// &lt;/summary&gt; /// &lt;param name=\"port\"&gt;监听端口&lt;/param&gt; public HttpServer(int port) { httpListener = new HttpListener(); httpListener.Prefixes.Add(string.Format(\"http://+:{0}/\", port)); } /// &lt;summary&gt; /// 启动Http服务器 /// &lt;/summary&gt; public void Start() { httpListener.Start(); httpListener.BeginGetContext(new AsyncCallback(GetContext), httpListener); } private void GetContext(IAsyncResult ar) { HttpListener httpListener = ar.AsyncState as HttpListener; HttpListenerContext context = httpListener.EndGetContext(ar); httpListener.BeginGetContext(new AsyncCallback(GetContext), httpListener); HttpListenerRequest request = context.Request; HttpListenerResponse response = context.Response; Dictionary&lt;string, string&gt; getArgs = new Dictionary&lt;string, string&gt;(); JObject postArgs = null; string[] keys = request.QueryString.AllKeys; if (keys.Count() &gt; 0) { foreach (var key in keys) { getArgs.Add(key, request.QueryString[key]); } } if (request.HttpMethod == \"POST\") { using (Stream stream = request.InputStream) { StreamReader reader = new StreamReader(stream, Encoding.UTF8); string body = reader.ReadToEnd(); string jsonText = \"{}\"; if (body.IndexOf(\"&lt;xml&gt;\") == 0) { XmlDocument doc = new XmlDocument(); doc.LoadXml(body); jsonText = JsonConvert.SerializeXmlNode(doc, Newtonsoft.Json.Formatting.None, true); } if (body.IndexOf(\"{\") == 0) { jsonText = body; } postArgs = JObject.Parse(jsonText); } } var callbackValue = HttpGotRequest?.Invoke(new HttpArgs(getArgs, postArgs)); #region 消息回应 if (callbackValue == null) return; response.ContentType = \"json\"; response.ContentEncoding = Encoding.UTF8; using (Stream output = response.OutputStream) { byte[] buffer = Encoding.UTF8.GetBytes(callbackValue.ToString()); output.Write(buffer, 0, buffer.Length); } #endregion } } 利用HttpClient在指定的域和端口监听Http请求。GetContext是Http请求的处理方法，它是一个异步方法，因此不会造成程序的阻塞，从而可以处理较高并发的请求。在处理Http请求时，首先对请求链接中的QueryString进行处理，获取到Get方式传递的参数，构造字典。然后读取Post流，判断Post的数据是xml格式还是json格式，然后进行相应的处理，构造JObject对象。利用字典和JObject对象即可构造Http请求参数，以事件参数的形式传递给监听者，待监听者进行处理后，拿到监听者返回的Http响应对象，以网络流的方式进行Http响应。而上文所说的监听者要做的事情很简单，只需要将请求参数传递给Application类，Application类就会根据参数进行下发、处理，并返回响应参数。拿到这个响应参数后再返回给HttpServer就好了。1234567891011121314151617class Program { private static HttpServer Server; static void Main(string[] args) { Server = new HttpServer(80); Server.HttpGotRequest += Server_HttpGotRequest; Server.Start(); Console.WriteLine(\"服务启动成功.\"); while(true) ; } private static HttpResponseArgs Server_HttpGotRequest(HttpArgs args) { return Application.Application.Handle(args); } } 这样，一个微型Http服务框架就写好了。 添加一个应用接下来将演示如何利用我们刚写好的这个服务框架搭建一个最简单的Http服务首先新建一个类，名字可以叫作Index。在我们的框架中，所有的应用都应实现IApplication接口，所有应用的数据都继承BaseModel类，它也不例外:12345678910111213141516171819202122class Index : IApplication { public string Name =&gt; \"\"; public HttpResponseArgs Handle(HttpArgs args) { var msg = new IndexModel { Code = 200, Message = \"Welcome to use ThinkNet frame!\", Data = DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\") }; return new HttpResponseArgs(JObject.FromObject(msg), ResponseType.Json); } }class IndexModel : BaseModel { public int Code { get; set; } public string Message { get; set; } public string Data { get; set; } } 应用的名字设置成空字符串，说明这是默认的app，当找不到合适的app进行处理时就由这个app来进行处理。在Handle方法中，我们没有用到请求参数，只是简单地返回了一个状态码、一条消息以及当前时间。这个数据结构被定义在IndexModel这个类中。由于并不需要进行数据库操作，因此无需对数据表字段进行重写。建立这两个类之后，就完成了一个最简单的app的定义。接下来只需要激活这个app即可。在Main方法中添加一行:1Application.Application.LoadApp(typeof(Application.Index.Index)); 完整的Main方法：123456789static void Main(string[] args){ Server = new HttpServer(80); Application.Application.LoadApp(typeof(Application.Index.Index)); Server.HttpGotRequest += Server_HttpGotRequest; Server.Start(); Console.WriteLine(\"服务启动成功.\"); while(true) ;} 此时即可按下F5，运行服务器。运行开服务器之后打开浏览器，地址栏输入127.0.0.1，回车，应该能够看到类似下面的页面：如果将app的Name进行修改，比如将Name改成index:1public string Name =&gt; \"index\"; 那么访问的链接中应带上app的名字，指定访问名为index的app：127.0.0.1?app=index访问的效果是一样的:那么，再添加多个app，进行不同的处理，道理都是一样的。有了这套框架，我们就可以很容易地搭建Http服务，而无需考虑底层Http服务器的运作，方便快捷，而且架构整洁。 在Linux系统中运行前面已经介绍过，.Net Core是跨平台的，我们以 .Net Core为基础编写的程序当然也是跨平台的。生成面向Linux系统的发布版，我们的代码就可以在Linux系统中运行。在解决方案根目录打开命令提示符，输入以下命令：1dotnet publish -c Release -r linux-x64 等待生成完成后，在/bin/Release目录下即可找到生成的结果。将publish文件夹复制到Linux系统中，直接输入./项目名称，程序即可在Linux系统中正常运行。访问上文中的地址，结果也是完全一样的。本文可能存在各种错误与疏漏，请读者包涵指正。","link":"/2019/08/07/基于-Net-Core的微型Http服务框架/"},{"title":"更换电脑或重装系统前后对原hexo博客的处理","text":"有时我们需要更换电脑或重装系统，这时就需要我们对hexo博客源文件进行备份 如果您不是很会用git,我建议您可以先选择用U盘拷贝，然后有时间的时候再好好学习一下git 一、 备份方法一 U盘拷贝并不是所有的文件都要拷贝，只需拷贝根目录下的 _config.yml package.json scaffolds/ source/ themes/ 方法二 分支管理在本地先初始化git仓库 1git init 关联远程仓库1git remote add origin http://github.com/xxxxxx(你hexo博客的地址) 然后创建并切换到hexo分支1git checkout -b hexo 将文件放入暂存区，并推送到远程仓库 二、在新文件夹中安装hexo(别忘了安装Git和Node.js)鼠标右键Git Bash 输入 (以下指令皆在Git bash中输入)1npm install hexo-cli -g 三、 初始化文件夹1hexo init 然后将源文件直接复制过来方法二的朋友们就把指定分支上的文件clone下来就行1git clone -b 分支名 仓库地址 四、安装相应模块12npm instalnpm install hexo-deployer-git --save //将文章部署到git的模块 五、进行测试123hexo cleanhexo ghexo s 在浏览器输入http://localhost:4000 就能看到博客了 六、重新部署到GitHub上删除原先的SSH重新生成SSH添加到github就好了 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 用下面两个指令确认你有没有输对 12git config user.namegit config user.email 生成SSH(一路回车就OK) 1ssh-keygen -t rsa -C &quot;youremail&quot; 感谢阅读 author:kcqnly","link":"/2019/07/14/hexo-2/"},{"title":"如何写出无法维护的代码","text":"下面的六个程序片段主要完成这些事情： 输出Hello, World 混乱C语言的源代码 下面的所有程序都可以在GCC下编译通过，只有最后一个需要动用C++的编译器g++才能编程通过。 hello1.c1234567891011#define _________ }#define ________ putchar#define _______ main#define _(a) ________(a);#define ______ _______(){#define __ ______ _(0x48)_(0x65)_(0x6C)_(0x6C)#define ___ _(0x6F)_(0x2C)_(0x20)_(0x77)_(0x6F)#define ____ _(0x72)_(0x6C)_(0x64)_(0x21)#define _____ __ ___ ____ _________#include&lt;stdio.h&gt;_____ hello2.c123456789#include &lt;stdio.h&gt;main(){ int x=0,y[14],*z=&amp;y;*(z++)=0x48;*(z++)=y[x++]+0x1D; *(z++)=y[x++]+0x07;*(z++)=y[x++]+0x00;*(z++)=y[x++]+0x03; *(z++)=y[x++]-0x43;*(z++)=y[x++]-0x0C;*(z++)=y[x++]+0x57; *(z++)=y[x++]-0x08;*(z++)=y[x++]+0x03;*(z++)=y[x++]-0x06; *(z++)=y[x++]-0x08;*(z++)=y[x++]-0x43;*(z++)=y[x]-0x21; x=*(--z);while(y[x]!=NULL)putchar(y[x++]);} hello3.c123456789101112131415#include&lt;stdio.h&gt;#define __(a) goto a;#define ___(a) putchar(a);#define _(a,b) ___(a) __(b);main() { _:__(t)a:_('r',g)b:_('$',p) c:_('l',f)d:_(' ',s)e:_('a',s) f:_('o',q)g:_('l',h)h:_('d',n) i:_('e',w)j:_('e',x)k:_('\\n',z) l:_('H',l)m:_('X',i)n:_('!',k) o:_('z',q)p:_('q',b)q:_(',',d) r:_('i',l)s:_('w',v)t:_('H',j) u:_('a',a)v:_('o',a)w:_(')',k) x:_('l',c)y:_('\\t',g)z:___(0x0)} hello4.c123456789int n[]={0x48, 0x65,0x6C,0x6C, 0x6F,0x2C,0x20, 0x77,0x6F,0x72, 0x6C,0x64,0x21, 0x0A,0x00},*m=n; main(n){putchar (*m)!='\\0'?main (m++):exit(n++);} hello5.c12345678910111213141516171819202122232425262728main(){int i,n[]={(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt; 1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))+((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))), (((1 &lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt;( 1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))+((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))+ (1 &lt;&lt;(1&gt;&gt;1))),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt; (1 &lt;&lt;1))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))- ((1 &lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1 &lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1 )))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))),(((1&lt;&lt;1)&lt;&lt; (1 &lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;( 1&lt;&lt;(1&gt;&gt;1)))-(1&lt;&lt;(1&gt;&gt;1))),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1 )&lt;&lt;(1&lt;&lt;1))+((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1))) -((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))),((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1) &lt;&lt;(1&lt;&lt;1)),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt; 1))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-(1&lt;&lt;(1&gt;&gt;1))),(((1&lt;&lt; 1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt; (1 &lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))-(1&lt;&lt;(1&gt;&gt;1))), (((1&lt;&lt;1 )&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))- ((1&lt;&lt;1)&lt;&lt; (1 &lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))+(1&lt;&lt;1)), (((1&lt;&lt;1)&lt;&lt; ( 1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1) &lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))-((1&lt;&lt;1) &lt;&lt;(1&lt;&lt; (1&gt;&gt;1)))), (((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1))- ((1 &lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))+((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;(1&gt;&gt; 1)))), (((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1) &lt;&lt;(1&lt;&lt;1))+(1&lt;&lt;(1 &gt;&gt;1))),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))+((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;( 1&gt;&gt;1))) + (1&lt;&lt; (1&gt;&gt;1)))}; for(i=(1&gt;&gt;1);i &lt;(((1&lt;&lt;1) &lt;&lt;(1&lt;&lt;1))+((1 &lt;&lt;1)&lt;&lt; (1&lt;&lt;(1&gt;&gt;1 ))) + (1&lt;&lt;1)); i++) printf(\"%c\",n[i]); } hello6.cpp下面的程序只能由C++的编译器编译（比如：g++） 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; #define _(_) putchar(_); int main(void){int i = 0;_( ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++i)_(++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++i)_(++++++++++++++ i)_(--++i)_(++++++i)_(------ ---------------------------- ---------------------------- ---------------------------- ---------------------------- ----------------i)_(-------- ----------------i)_(++++++++ ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++i) _(----------------i)_(++++++ i)_(------------i)_(-------- --------i)_(---------------- ---------------------------- ---------------------------- ---------------------------- ---------------------------- ------i)_(------------------ ---------------------------- i)return i;} 下面是一个Step by Step的教程，教你如何把一个清晰的代码变得复杂难懂的。当然，这只是一个“简明教程”了。还是那句话——“本文仅供朋友们“消遣作乐”，如果你要觉得有意思的话，帮忙推给其他同学。如果你觉得没什么意思的话，一笑了之。仅供娱乐而已，不必太过认真。” 开始程序下面是一个找出素数的程序： 12345678910111213141516171819void primes(int cap){ int i, j, composite; for(i = 2; i &lt; cap; ++i) { composite = 0; for(j = 2; j * j &lt; i; ++j) { composite += !(i % j); } if(!composite){ printf(\"%dt\", i); } }} int main(){ primes(100);} 第一步、把for变成while通常来说，for循坏要以while循坏简单一些，上面的程序有二重for循环，我们不但要把其变成while循环，而且还要把二重循环的变成一重的循环，然后使用大量的if-else语句来判断。 123456789101112131415161718192021void primes(int cap){ int i, j, composite, t = 0; while(t &lt; cap * cap) { i = t / cap; j = t++ % cap; if(i &lt;= 1); else if(!j) composite = j; else if(j == i &amp;&amp; !composite) printf(\"%dt\",i); else if(j &gt; 1 &amp;&amp; j &lt; i) composite += !(i % j); }} int main(){ primes(100);} 第二步，把循坏变成递归递归在某些时候是可以把代码变得简单，但大多数的情况下是把代码变得复杂，而且很没有效率。下面是把上面的while循环变成了递归。变成了递归后，函数的参数都变成3个了。 123456789101112131415161718192021void primes(int cap, int t, int composite){ int i,j; i = t / cap; j = t % cap; if(i &lt;= 1) primes(cap,t+1,composite); else if(!j) primes(cap,t+1,j); else if(j == i &amp;&amp; !composite) (printf(\"%dt\",i), primes(cap,t+1,composite)); else if(j &gt; 1 &amp;&amp; j &lt; i) primes(cap,t+1, composite + !(i % j)); else if(t &lt; cap * cap) primes(cap,t+1,composite);} int main(){ primes(100,0,0);} 第三步，弄乱代码结构/使用没有含义的变量名关于如何弄乱代码结构，其中一个小技巧是，使用“？”表达式代替if-else语句。 1234567891011121314void primes(int m, int t, int c){ int i,j; i = t / m; j = t % m; (i &lt;= 1) ? primes(m,t+1,c) : (!j) ? primes(m,t+1,j) : (j == i &amp;&amp; !c) ? (printf(\"%dt\",i), primes(m,t+1,c)) : (j &gt; 1 &amp;&amp; j &lt; i) ? primes(m,t+1,c + !(i % j)) : (t &lt; m * m) ? primes(m,t+1,c) : 0;} int main(){ primes(100,0,0);} 第四步，取消临时变量临时变量一般用来保存反复使用的一个表达式的值。使用大量重复的表达式来取消这些临时变量的也可以让代码复杂起来。 123456789101112void primes(int m, int t, int c){ ((t / m) &lt;= 1) ? primes(m,t+1,c) : !(t % m) ? primes(m,t+1, t % m) : ((t % m)==(t / m) &amp;&amp; !c) ? (printf(\"%dt\",(t / m)), primes(m,t+1,c)) : ((t % m)&gt; 1 &amp;&amp; (t % m) &lt; (t / m)) ? primes(m,t+1,c + !((t / m) % (t % m))) : (t &lt; m * m) ? primes(m,t+1,c) : 0;} int main(){ primes(100,0,0);} 第五步，继续弄乱变量名我们知道，下划线是合法的变量名，所以，我们不妨用，_，____来代替m，t，c。函数名也可以使用下划线来代替。让我们来看看求素数的函数能变成什么。 12345678910111213void _(int __, int ___, int ____){ ((___ / __) &lt;= 1) ? _(__,___+1,____) : !(___ % __) ? _(__,___+1,___ % __) : ((___ % __)==(___ / __) &amp;&amp; !____) ? (printf(\"%dt\",(___ / __)), _(__,___+1,____)) : ((___ % __) &gt; 1 &amp;&amp; (___ % __) &lt; (___ / __)) ? _(__,___+1,____ + !((___ / __) % (___ % __))) : (___ &lt; __ * __) ? _(__,___+1,____) : 0;} int main(){ _(100,0,0);} 第六步，移除常量在上面的程序中，还有一些常量，你可以通过增加一个宏定义，或是增加一个函数的形参来取代这一常量。 123456789101112void _(int __, int ___, int ____, int _____){ ((___ / __) &lt;= _____) ? _(__,___+_____,____,_____) : !(___ % __) ? _(__,___+_____,___ % __, _____) : ((___ % __)==(___ / __) &amp;&amp; !____) ? (printf(\"%dt\",(___ / __)), _(__,___+_____,____,_____)) : ((___ % __) &gt; _____ &amp;&amp; (___ % __) &lt; (___ / __)) ? _(__,___+_____,____,_____ + !((___ / __) % (___ % __))) : (___ &lt; __ * __) ? _(__,___+_____,____,_____) : 0;} int main() { _(100,0,0,1);} 程序到这里应该差不多了。还是那句话——“每一个程序员都有把源代码弄复杂的潜质”，大家好自为之。 感谢阅读 author:Reyunn","link":"/2019/06/23/code/"},{"title":"如何用程序实现魔方的旋转","text":"魔方是一种很受欢迎的益智玩具，同时魔方运动也被称为“手指三大极限运动”之一。本篇博文将就如何使用程序实现一个三阶魔方的旋转提出我自己的思路 魔方的结构一个普通的三阶魔方具有六个面、二十六个块。其中，有六个中心块，十二个棱块，八个角块。中心块的相对位置是不会变的，无论你如何旋转魔方，六个中心块的位置始终是不会变化的。棱块处于两个面交界的位置，拥有两个颜色，因此也有两种朝向。所以一个棱块的位置可能有12×2=24种情况。角块处于三个面交界的位置，有三个颜色，因此有三种朝向。一个角块的位置可能有8×3=24种情况。 思考一个问题如何确定一个魔方？按照日常经验，只要魔方的六个面都确定了，那么这个魔方的情况就完全确定了。这的确是一种思路。我们可以考虑使用一个二维数组来存放魔方六个面的情况：123456789101112131415161718#define WHITE 0#define YELLOW 1#define RED 2#define ORANGE 3#define BLUE 4#define GREEN 5int[6][9] = {0};void init_cube(){ for(int i=0; i&lt;6; i++) { for(int j=0; j&lt;9; j++) { int[i][j] = i; } }} 用数字0代表白色，数字1代表黄色…这样我们便有了一个6*9的数组，代表每个面的每个色块分别是什么颜色，这样的一个数组就可以表示一个魔方。但是这种方式真的合适吗？仔细考虑一下，一方面，一个魔方面与面的颜色之间是存在关联的，比如，一个棱块上的两个颜色，必然不可能是两个相对面的颜色，一个角块上的三个颜色，必然是三个相邻的面的颜色。而我们分别储存六个面的颜色信息，这些数据之间就缺少了由魔方的结构所带来的约束关系，因此我们必然会写更多的代码来弥补这种缺失的关联。另一方面，魔方是一个三维空间中的结构，我们用这种方式表示一个魔方，相当于是将魔方六个面展开，降成了二维。如此一来，在处理三维的旋转时，必然会遇到困难。因此这种方式虽然很容易想到，也比较简单，但是后续的实现会相当复杂，因此是不合适的。 魔方结构的数字化综合以上分析，我们对魔方结构的表示一定要注意几个关键点： 要以三维的形式来表示 不能丢失魔方结构决定的约束 易于处理旋转等操作 所以，我们可以考虑以魔方的块为单位，用26个方块的位置和朝向来决定一个魔方。说到位置，我们很自然地就能想到利用控件坐标系中的一组向量来表示方块的位置。首先，建立空间坐标系。我们选择以立方体的中心为原点，向右为X轴正向，向前为Y轴正向，向上为Z轴正向：这样一来，魔方中所有方块的位置就都可以用一组向量来表示了。比如下图中，红色标明的中心块可以表示为 $\\{0,1,0\\}^T$，蓝色标明的棱块位置可以表示为 $\\{-1,0,1\\}^T$，绿色标明的角块位置可以表示为 $\\{1,-1,1\\}^T$。接下来，我们考虑一下如何表示每个方块的朝向。所谓朝向，无非就是哪个方向对应哪个颜色。因此，我们也可以使用与位置类似的方法，用一组向量来表示方块的朝向。我们用R代表红色，O代表橙色，W代表白色，Y代表红色，B代表蓝色，G代表绿色。考虑到棱块只有两个方向有颜色，中心块只有一个方向有颜色，为了统一，我们引入X，代表某个方向没有颜色。如下图所示，中心块的颜色可以表示为 $\\{X,B,Z\\}^T$，右边棱块的颜色可以表示为 $\\{R,G,X\\}^T$，右上角角块的颜色可以表示为 $\\{G,Y,R\\}^T$。这样，我们就可以用两个向量来表示魔方中一个块的位置和颜色。比如上图中的角块可以表示为： \\begin{cases} 位置：\\{1,1,1\\}^T\\\\ 颜色：\\{G,Y,R\\}^T \\end{cases}这样，只需要26组向量，我们便可以用数据表示出一个魔方。 魔方的旋转魔方的旋转可以理解为空间中的坐标变换，而我们刚才已经可以用用向量来表示魔方的结构，因此直接使用旋转矩阵，即可完成对魔方的旋转。向量旋转公式： \\begin{Bmatrix} x'\\\\y'\\\\z' \\end{Bmatrix} =R* \\begin{Bmatrix} x\\\\y\\\\z \\end{Bmatrix}绕$x,y,z$轴旋转时，$R$的值分别如下： R_x= \\begin{Bmatrix} 1 & 0 & 0\\\\ 0 & cos\\theta & -sin\\theta\\\\ 0 & sin\\theta & cos\\theta \\end{Bmatrix} R_y= \\begin{Bmatrix} cos\\theta & 0 & sin\\theta\\\\ 0 & 1 & 0\\\\ -sin\\theta & 0 & cos\\theta \\end{Bmatrix} R_z= \\begin{Bmatrix} cos\\theta & -sin\\theta & 0\\\\ sin\\theta & cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{Bmatrix}其中$\\theta$是顺旋转的角度。取$\\theta=90\\degree$，即为顺时针旋转90度，反之为逆时针旋转90度。让我们来测试一下。假如将上图角块所在的顶层沿顺时针方向旋转90度，那么旋转前后该角块的数据： \\begin{cases} 位置：\\{1,1,1\\}^T\\\\ 颜色：\\{G,Y,R\\}^T \\end{cases}\\tag前 \\begin{cases} 位置：\\{-1,1,1\\}^T\\\\ 颜色：\\{Y,G,R\\}^T \\end{cases}\\tag后如果我们用旋转矩阵进行变换，得到以下结果： \\begin{Bmatrix} cos\\theta & -sin\\theta & 0\\\\ sin\\theta & cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{Bmatrix} *\\begin{Bmatrix} 1\\\\1\\\\1 \\end{Bmatrix}= \\begin{Bmatrix} -1\\\\1\\\\1 \\end{Bmatrix} \\begin{Bmatrix} cos\\theta & -sin\\theta & 0\\\\ sin\\theta & cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{Bmatrix} *\\begin{Bmatrix} G\\\\Y\\\\R \\end{Bmatrix}= \\begin{Bmatrix} -Y\\\\G\\\\R \\end{Bmatrix}颜色向量中的符号代表颜色面向的方向与坐标轴方向相反。舍弃掉符号，运算所得的结果与魔方实际旋转后的结果完全一致，这就证明了我们的方法是正确的。这样一来，我们就解决了魔方用数据来表示这一问题，也解决了魔方的旋转。你可以顺着这个思路，尝试自己编写代码来实现。 感谢阅读 author:AZ","link":"/2019/06/22/如何用程序实现魔方的旋转/"},{"title":"利用Jenkins实现网页自动部署","text":"在上一篇文章中，我们在Ubuntu下搭建了Jenkins自动部署环境，这篇文章将利用Jenkins实现网页的自动部署。 初始化Jenkins在浏览器输入服务器地址:端口号进入Jenkins的控制台，如127.0.0.1:8081。第一次启动时，要求输入默认管理员密码。默认管理员密码存放在/var/lib/jenkins/secrets/initialAdminPassword文件中。使用vim打开此文件，复制管理员密码并填入相应位置，点击继续。接着进入插件安装的页面，选择安装推荐插件，等待插件安装完成。接着按照指引，完成后续部分。 安装Gitee插件由于Github在国内访问较慢，我们选择国内优秀的代码托管平台Gitee构建代码仓库。进入Jenkins工作台后，点击左侧的系统管理，然后找到插件管理，点击可选插件，在右上角过滤条件中输入”Gitee”，勾选Gitee插件前面的复选框，点击页面最下端的”直接安装”。 注册Gitee账号如果你已经有Gitee账号，则跳过这一步Gitee官网：https://gitee.com/ 配置Gitee for Jenkins进入Jenkins控制台，点击系统管理-&gt;系统设置，找到”Gitee 配置”。 连接名：Gitee Gitee域名Url：https://gitee.com 证书令牌：点击”添加”-&gt;”Jenkins”，在弹出的窗口中，类型选择”Gitee令牌”。接着进入 https://gitee.com/profile/personal_access_tokens ,点击”生成新令牌”,描述填写”Jinkins”，点击提交，复制生成的令牌。然后回到Jenkins控制台，将复制的令牌粘贴到”Gitee APIV5 私人令牌”一项中，点击添加，窗口关闭。接着点击证书令牌后的下拉框，选择”Gitee API令牌”，再点击”测试连接”，若测试成功，则点击页面下方的保存。在Gitee创建一个项目操作类似Github。点击”创建仓库”，输入仓库名称，”是否开源”选择”公开”，”分支模型”选择”生产/开发模型”,然后点击创建。在Jenkins创建一个任务点击Jenkins控制台左侧的”新建任务”,输入任务名，如”Pages”,选择”构建一个自由风格的软件项目”，确定找到源码管理，选择”Git”，”Repository URL”填写你的项目地址.git，再找到构建触发器，选择”Gitee webhook”，只勾选”推送代码”，在”允许触发构建的分支”中选择”根据分支名过滤”，”包括”一项中填写”master”。在”Gitee WebHook密码”一项，点击”生成”，并复制生成的密码。接着找到”构建”，点击”增加构建步骤”，选择”执行shell”，接着在命令中填写以下内容123echo 开始执行自动部署sudo sh /home/pull.shecho 自动部署结束 最后点击保存。 配置Gitee WebHook在Gitee中打开你的项目，点击”管理”-&gt;”Web Hooks”，点击添加 Url: http://服务器地址:Jenkins端口/project/Jenkins中的任务名 (如:http://azhrzho.com:8081/project/Pages) 密码: 上一步生成的WebHook密码 选择事件: 只勾选Push然后保存，点击”测试”,若请求结果类似以下结果，则配置成功。1push_hooks ref = refs/heads/master commit sha = xxxxxxxxx has been accepted. 配置服务器部署操作使用SSH登录服务器，输入以下命令12345$ cd /home$ git clone 你的Gitee项目地址.git# 如： git clone https://gitee.com/xxx/Pages.git$ ln -s /home/你的项目名字 /var/www/html/pages# 如： ln -s /home/Pages /var/www/html/pages 接着编写一个脚本12$ vim pull.sh# 在文本编辑器中输入以下内容 123#!/bin/bashcd /home/你的项目名字git pull 保存文件并退出编辑器。此时，自动部署已经配置完毕。你可以在任意一台电脑上对你的项目代码进行修改并推送，每次推送后，新的网页将被即时部署在 http://服务器地址/pages 当中。 添加部署后邮件提醒虽然自动部署已经配置完成，但每次部署后我们无法接收到是否部署成功的消息。因此我们可以给任务添加邮件提醒。首先，进入Jenkins控制台，点击”系统管理”-&gt;”系统设置”，找到”系统管理员邮件地址”,填写你的QQ邮箱。继续向下，找到”Extended E-mail Notification”,并点击”高级”。 SMTP server: smtp.qq.com Default user E-mail suffix: @qq.com Use SMTP Authentication: 勾选 User Name: 你的QQ账号 Password：一会再说 Use SSL：勾选 SMPT port：465 Default Content Type：HTML Default Recipients：你的QQ邮箱 Default Subject：填写以下内容 1$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS! Default Content：填写以下内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志&lt;/title&gt; &lt;/head&gt; &lt;body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\" offset=\"0\"&gt; &lt;table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\" style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\"&gt; &lt;tr&gt; 本邮件由系统自动发出，无需回复！&lt;br/&gt; 以下为${PROJECT_NAME }项目构建信息&lt;/br&gt; &lt;td&gt;&lt;font color=\"#CC0000\"&gt;构建结果 - ${BUILD_STATUS}&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;br /&gt; &lt;b&gt;&lt;font color=\"#0B610B\"&gt;构建信息&lt;/font&gt;&lt;/b&gt; &lt;hr size=\"2\" width=\"100%\" align=\"center\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;项目名称 ： ${PROJECT_NAME}&lt;/li&gt; &lt;li&gt;构建编号 ： 第${BUILD_NUMBER}次构建&lt;/li&gt; &lt;li&gt;触发原因： ${CAUSE}&lt;/li&gt; &lt;li&gt;构建状态： ${BUILD_STATUS}&lt;/li&gt; &lt;li&gt;构建日志： &lt;a href=\"${BUILD_URL}console\"&gt;${BUILD_URL}console&lt;/a&gt;&lt;/li&gt; &lt;li&gt;构建 Url ： &lt;a href=\"${BUILD_URL}\"&gt;${BUILD_URL}&lt;/a&gt;&lt;/li&gt; &lt;li&gt;工作目录 ： &lt;a href=\"${PROJECT_URL}ws\"&gt;${PROJECT_URL}ws&lt;/a&gt;&lt;/li&gt; &lt;li&gt;项目 Url ： &lt;a href=\"${PROJECT_URL}\"&gt;${PROJECT_URL}&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;&lt;font color=\"#0B610B\"&gt;失败用例&lt;/font&gt;&lt;/h4&gt;&lt;hr size=\"2\" width=\"100%\" /&gt;$FAILED_TESTS&lt;br/&gt;&lt;h4&gt;&lt;font color=\"#0B610B\"&gt;最近提交(#$SVN_REVISION)&lt;/font&gt;&lt;/h4&gt;&lt;hr size=\"2\" width=\"100%\" /&gt;&lt;ul&gt;${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"&lt;li&gt;%d [%a] %m&lt;/li&gt;\"}&lt;/ul&gt;详细提交: &lt;a href=\"${PROJECT_URL}changes\"&gt;${PROJECT_URL}changes&lt;/a&gt;&lt;br/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 继续向下，找到”邮件通知”，点击”高级”，这里的配置与上文一样，不再赘述。接着，填写两处的密码。这里的密码不是QQ密码，而是QQ邮箱的授权码。下面介绍QQ邮箱获取授权码的方法。 获取QQ邮箱授权码第一步，进入QQ邮箱，点击”设置”-&gt;”账户”第二步，找到”POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务”，点击”生成授权码”第三步，根据指引生成授权码，并复制最后，将复制的授权码填写到Jenkins的两处邮箱密码配置中，点击保存。 为任务添加邮件提醒返回Jenkins控制台主页，点击你创建好的任务，再点击”配置”，找到”构建后操作”，点击”增加构建后操作步骤”,选择”Editable Email Notification”。”Content Type”选择”HTML”，再点击”Advanced Settings”，删除所有默认的Triggers，再点击”Add Triggers”，选择”Always”，在”Send To”配置中添加”Developers”和”Recipient List”，最后点击保存。至此，通知邮件配置完毕。你可以尝试推送一次你的项目，然后你会接收到一封邮件，说明部署成功或失败，并附带本次部署的详细信息。 感谢阅读 author:AZ","link":"/2019/06/16/利用Jenkins实现网页自动部署/"},{"title":"Ubuntu下搭建Jenkins自动部署环境","text":"安装JDK123456# 添加java的ppa$ sudo add-apt-repository ppa:webupd8team/java# 更新软件源$ sudo apt-get update# 安装java8$ sudo apt-get install oracle-java8-installer 安装tomcat81$ sudo apt-get install tomcat8 tomcat8-docs tomcat8-examples tomcat8-admin -y 配置权限1$ sudo vim /var/lib/tomcat8/conf/tomcat-users.xml 在文件尾添加以下内容123&lt;role rolename=\"manager-gui\"/&gt;&lt;role rolename=\"admin-gui\"/&gt;&lt;user username=\"root\" password=\"123456\" roles=\"manager-gui,admin-gui\"/&gt; 重启服务1$ sudo service tomcat8 restart 安装Jenkins使用Jenkins官方软件仓库，添加软件仓库密钥1$ wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add - 将官方提供的软件仓库地址加入到本地的apt软件源中，本地用于存放软件源的文件在/etc/apt/sources.list1deb https://pkg.jenkins.io/debian-stable binary/ 保存文件并退出，更新软件源并安装Jenkins12$ sudo apt-get update$ sudo apt-get install jenkins 下载速度比较慢，可耐心等待。安装结束后启动Jenkins1$ sudo /etc/init.d/jenkins start 若遇到启动失败的情况，可能是端口冲突，通过以下方法更改端口1234567$ sudo vim /etc/default/jenkins#修改如下内容HTTP_PORT=8081#启动jenkins服务$ sudo /etc/init.d/jenkins start 此时即可通过你的IP:端口号访问Jenkins了，如127.0.0.1:8081Ubuntu下的Jenkins自动部署环境搭建完成。 感谢阅读 author:AZ","link":"/2019/06/15/Ubuntu下搭建Jenkins自动部署环境/"},{"title":"在一台电脑上管理两个hexo博客","text":"出于个人原因，要在电脑上管理两个博客，在这期间也是遇到了不少问题不过都已一一解决了写这篇博文来分享一下我解决这些问题的方法 主要问题当你生成SSH添加到Github上时由于之前部署第一个博客时你可能输入了 123git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;ssh-keygen -t rsa -C &quot;youremail&quot; 这里的global是全局设置，所以再次输入这两条指令，然后生成SSH，会覆盖之前一个博客的SSH，当你再对之前的博客进行hexo d时，就会报错 解决方法一、生成新的SSH先别输入git config…那两个指令先输入 12345ssh-keygen -t rsa -C &quot;your_new_email&quot; //然后gitbash里会这样Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): //这里输入新的id_rsa的名字，以便于和之前的id_rsa区分 这个新的SSH貌似没有出现在C盘的.ssh文件夹，而是出现在git bash的那个文件夹，你可以把那两个id_rsa都复制到.ssh文件夹里然后设置新Github的SSH key（将新的SSH添加到GitHub上） 三、添加新的 SSH 密钥到 SSH agent中12345ssh-add -D //如果出现Could not open a connection to your authentication agent//那就输入ssh-agent bashssh-add xxxxxx #旧密钥名称，一般是id_rsassh-add xxxxxx #新创建的密钥名称 四、取消全局配置12git config --global --unset user.namegit config --global --unset user.email 然后分别到两个博客文件里的.deploy_git文件夹下面右键git bash设置用户名和邮箱（其实当时处理第一个博客的时候，直接在.deploy_git文件夹下设置user.name和user.email,而不用全局设置，就OK）12git config user.name &quot;yourname&quot;git config user.email &quot;youremail&quot; 然后hexo clean hexo g hexo d 试一试 应该部署好了 如果出现了这种情况12&gt;FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html &gt; 只需将_config.yml里的deploy部分仓库的地址改为https://yourname:yourpassword@github.com/yourname/yourname.github.io.git(你的GitHub用户名和密码) 至此就处理好了 感谢阅读 author:kcqnly","link":"/2019/06/08/hexo-1/"},{"title":"震惊!57行代码实现刷在线时长","text":"不知道大家有没这样的经验，有些网站下载东西需要积分，而在线时间可以积累积分，但是网页15分钟就会超时，你需要一直开着浏览器并刷新，要是有个脚本一直在后台跑着就好了，24小时在线，这就是我们要写的内容。 因为此类网站很多，我也不可能一篇盖全。所以我们便用学校的一个需要刷在线时长的网站演示。 项目介绍 我们学校大学语文的计分方式是通过其在线时长的积累，需要在网站上浏览1000分钟的内容，但是网站上即没有视频也没有文章，就是让你傻傻的浏览。所以我写了这个小工具，帮助大家自动刷满时长。 whut-zgyw项目地址： Github 地址 ：https://github.com/Reyunn/whut-zgyw 项目依赖： require cheerio 项目使用嘿嘿，我在这里先教大家使用，在慢慢分析其原理与思想。 安装运行环境：因为本项目是基于Node.js开发的，所以你需要前往Node.js的网站安装最新版的Node.js。 Node.js官网 ：https://nodejs.org/en/ 获取本项目：这里默认大家都会使用Git了，所以直接将我的项目Clone下来就好。如果大家普遍反馈还不会Git的话，我后续会推出几篇文章，带你认识认识Git。 1git clone https://github.com/Reyunn/whut-zgyw.git 安装依赖：1npm install 运行：12node index.js 学号 密码//如 node index.js 0121709360222 0121709360222 运行效果图 成功运行后你会发现脚本每分钟都会自动执行一次，最终帮你刷满1000分钟。 代码分析到此你已经能实现帮自己和同学完成这1000分钟的内容，如果你想弄清楚其中的原理，那就耐心往后看。希望下面的文字能对你有所启发。 代码 所有的代码由两个函数和3句命令构成。我们将此代码的执行流程带你分析一下这个项目。 引用与定义12345const cheerio = require(\"cheerio\");const request = require(\"request\");const URL = \"http://59.69.102.9/zgyw/index.aspx\";const URL_ARTICLE = \"http://59.69.102.9/zgyw/study/LearningContent.aspx?type=1&amp;id=1&amp;learningid=3073\";let cookie = \"\"; 对于变量的类型采样ES6标准编写，即常量为const变量为let，在这里我引用了两个第三方模块cheerio与request分别起着解析网页与发送请求的作用。常量URL是我们登入及点击主页的地址。URL_ARTICLE是我们模拟浏览的地址。而变量cookie则是我们记录网站cookie的变量。 主函数123const args = process.argv.splice(2);if (args.length != 2) console.log(\"请输入用户名和密码！\");f(); 这里我们用args接受cmd传入的用户名及密码，并提醒用户正确输入信息。此后执行f()函数，此函数是本 项目的主要部分。 f() 函数123456789101112131415161718192021222324252627async function f() { setTimeout(f, 60000); await request({ url: URL_ARTICLE, headers: { 'Cookie': cookie } }, () =&gt; { }); await request({ url: URL, headers: { 'Cookie': cookie } }, (error, response, body) =&gt; { if (!error &amp;&amp; response.statusCode == 200) { const $ = cheerio.load(body.toString()); if ($(\"#ctl00_ContentPlaceHolder1_lblonlineTime font\").html() != null) { const time_temp = parseInt($(\"#ctl00_ContentPlaceHolder1_lblonlineTime font\").html().substring(0, 4)); console.log(new Date() + \" \" + args[0] + \" \" + time_temp); } else { login(); } } });} 首先我将其设置为async函数，因为我们需要以同步的方式实现该功能。这个函数仅三条内容 setTimeout(f, 60000); 实现该函数每1分钟，自动执行。 第一个request请求，浏览文章 第二个request请求，浏览主页，并判断是否登入，若未登入执行登入操作，若登入成功则打印目前时长。 感谢阅读 author:Reyunn","link":"/2019/05/28/网站刷在线时长/"},{"title":"寝室微型网络服务器的配置（Ubuntu+LAMP)","text":"第一步 安装UbuntuUbuntu下载地址：https://www.ubuntu.com/download/desktop 使用软碟通工具将光盘镜像文件写入到U盘，服务器从U盘启动安装Ubuntu系统。建议安装时断网，防止安装过程中下载更新。整个过程大概需要40分钟。 第二步 配置SSH 安装SSH1234# 更新软件源$ sudo apt-get update# 安装ssh$ sudo apt-get install openssh-server openssh-client 配置SSH12# 打开ssh配置文件$ sudo vim /etc/ssh/sshd_config 修改以下配置项123456# 允许root账号登录PermitRootLogin yes# 自定义SSH端口号Port 2222# 允许密码登录PasswordAuthentication yes 保存文件，输入以下命令1234# 设置开机自动启动ssh服务$ sudo update-rc.d ssh defaults# 启动ssh服务$ sudo service ssh start 修改root账号的密码12345# 更改root账户默认密码$ sudo passwd&gt; 输入新的UNIX密码：&gt; 重新输入新的UNIX密码：&gt; passwd：已成功更新密码 查看本机IP12345$ ifconfig -a&gt; enp1s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.1.101 netmask 255.255.255.0 broadcast 192.168.1.255 ... ... 此时即可通过局域网内另一台电脑SSH登录到此服务器上（推荐使用XShell工具），本博文剩余部分全部使用root账户SSH登录到服务器上进行操作。 第三步 内网穿透或DDNS如果你的寝室网络为内网IP，那么你需要使用内网穿透工具，将服务器穿透到公网。如果你的寝室网络为公网IP，但这个IP会变化，那么你需要使用动态域名解析（DDNS）。 如何判断我的IP是内网IP还是公网IP？ 百度搜索”IP”，你就会看到自己的外网IP地址。然后Ping这个地址，若有相应，那么恭喜你，你的IP是公网IP；若Ping无响应，那么你的IP是内网IP 内网IP：使用FRP工具进行内网穿透FRP是一个免费的内网穿透软件。使用FRP进行内网穿透，你需要拥有一台可以连接到公网的服务器 服务器端配置我的公网服务器是固定IP，系统是WindowsServer。访问 http://diannaobos.iok.la:81/frp/frp-v0.20.0/ 下载frp_0.20.0_windows_amd64.zip ，解压，在cmd中运行frps.exe Linux系统服务端的配置与Windows系统类似，具体可参考客服端配置 客户端配置使用wet命令下载frp:1234567891011# 创建一个文件夹用来放frp$ mkdir /home/frp$ cd /home/frp# 下载frp$ wget http://diannaobos.iok.la:81/frp/frp-v0.20.0/frp_0.20.0_linux_amd64.tar.gz# 解压$ tar -xzf frp_0.20.0_linux_amd64.tar.gz# 进入解压后的文件夹$ cd frp_0.20.0_linux_amd64# 编辑配置文件$ vim frpc.ini 配置文件样例：12345678910111213141516171819202122[common]# 公网服务端的地址或IPserver_addr = xxx.xxx.xxx.xxx# frp服务器端口，默认7000，与服务端一致server_port = 7000# 添加一个名为ssh的端口映射[ssh]type = tcplocal_ip = 127.0.0.1# 本地端口2222，将来配置SSH时使用的端口应和这个一致local_port = 2222# 映射到公网服务器的端口remote_port = 2222[web]type = tcplocal_ip = 127.0.0.1# 本地web服务器80端口local_port = 80、、# 映射到公网服务器的8080端口remote_port = 8080 保存文件并退出vim编辑器，使用以下命令测试运行frpc:1$ frpc -c frpc.ini 若无错误，即可关闭当前终端，重新启动一个新的终端，输入以下命令后台运行frpc:12$ cd /home/frp/frp_0.20.0_linux_amd64$ nohup ./frpc -c ./frpc.ini &gt; /dev/null 2&gt;&amp;1 &amp; 至此，内网穿透配置完毕。你可以使用 ‘公网IP或公网地址:2222’ 来SSH登录到你的服务器，或使用 http://公网IP或公网地址:8080 来访问你的服务器上的网页资源。 公网IP：利用GoDaddy API实现DDNSGoDaddy是全球最大的域名注册商，它提供了一些API，可以实现动态域名解析 在GoDaddy注册账号并购买一个域名首先在GoDaddy购买一个域名，很多域名都是有优惠的，10-30元就可以注册一个域名一年的使用权。如果你已经在GoDaddy拥有域名，那么可以跳过这一步。 注册GoDaddyAPI打开GoDaddy API网站：https://developer.godaddy.com/ ，点击“API Keys”，登录自己的账号，点击“Create New API Key”，复制生成的密钥并妥善保存。 编写Python脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import urllib.requestimport http.clientimport jsonimport timedef log(info): print(time.strftime(\"[%Y-%m-%d %H:%M:%S]\", time.localtime())+info)def update_NS(domain, ip_addr): api_url = 'https://api.godaddy.com/v1/domains/' + domain + '/records' # 此处替换为你的secretID secret_id = '*************************' # 此处替换为你的secretKey secret_key = '************************' head = {} head['Accept'] = 'application/json' head['Content-Type'] = 'application/json' head['Authorization'] = 'sso-key ' + secret_id + ':' + secret_key records_a = { \"data\": ip_addr, \"name\": \"@\", \"ttl\": 600, \"type\": 'A', } #必须包含的Record records_NS01 = { \"data\": \"ns07.domaincontrol.com\", \"name\": \"@\", \"ttl\": 3600, \"type\": \"NS\", } records_NS02 = { \"data\": \"ns08.domaincontrol.com\", \"name\": \"@\", \"ttl\": 3600, \"type\": \"NS\", } put_data = [records_a, records_NS01, records_NS02] try: req = urllib.request.Request(api_url, headers=head, data=json.dumps(put_data).encode(), method=\"PUT\") rsp = urllib.request.urlopen(req) code = rsp.getcode() if code == 200: log('域名解析更新成功:' + domain + ' -&gt; ' + ip_addr) else: log('域名解析更新失败.') except: log('update_NS中发生了错误.') log('域名解析更新失败.')def get_IP(): try: url_ip = 'http://2019.ip138.com/ic.asp' req = urllib.request.Request(url_ip, method=\"GET\") rsp = urllib.request.urlopen(req) data = rsp.read() data_str = str(data) left = data_str.index('[') + 1 right = data_str.index(']') ip = data_str[left:right] return ip except: log('get_IP中发生了错误.') return \"\"# 此处替换为你的域名domain = 'xxxxx.xxx'last_ip = \"\"while True: crt_ip=get_IP() if crt_ip!=\"\" and crt_ip!=last_ip: log('监测到本机IP更新:' + crt_ip) last_ip=crt_ip update_NS(domain, last_ip) time.sleep(5) 该脚本每隔5秒检测一次本机IP变化，并通过接口更新域名的A记录，实现DDNS的效果。 在任意位置创建一个py脚本文件，输入以上脚本，注意脚本中部分变量要替换为你的数据。输入以下命令来测试脚本：123# 切换到脚本所在的目录$ cd /home/ddns$ python3 ddns.py 若脚本工作正常，按下Ctrl + C 终止脚本运行，然后输入以下命令后台运行脚本：1$ nohup ./ddns.py &gt; ddns.log 2&gt;&amp;1 &amp; 脚本的输出会重定向到ddns.log这个文件，你可以打开这个文件来查看脚本输出是否正常。 一切没有问题的话，你就可以通过域名来访问你的服务器了。 第四步 安装Apache1$ sudo apt-get install apache2 -y 安装完成后Apache会自动启动。你也可以通过以下命令手动启动Apache：1$ sudo service apache2 start 使用浏览器访问你的IP或域名，若你能看到Ubuntu Apache2的欢迎页，证明你的Apache已经正常运行。 第五步 安装Mysql1234# 安装MySQL$ sudo apt install mysql-server mysql-client# 启动MySQL服务$ sudo service mysql start 若你使用root账号ssh登录到服务器执行命令，则安装过程中无需设置任何密码。安装完成后在终端输入指令 ‘mysql’ ,若能够进入mysql终端，则MySQL服务正常运行。 第六步 安装PHP1234# 安装PHP及相关组件$ sudo apt install php-mysql php-curl php-json php-cgi php libapache2-mod-php# 重启Apache服务$ sudo service apache2 restart 验证PHP安装，在www/html目录下新建一个php脚本文件1$ vim /var/www/html/phpinfo.php 输入以下代码：123&lt;?php echo phpinfo();?&gt; 保存并退出Vim编辑器，在浏览器中打开 http://你的地址或域名/phpinfo.php ,若你能够看到PHP的欢迎页面，说明你的PHP安装成功。 第七步 安装PHPMyAdminPHPMyAdmin是一个基于PHP的MySQL数据库管理系统，能够使你方便地对数据库进行管理。123$ sudo apt install php-mbstring php7.0-mbstring php-gettext$ sudo systemctl restart apache2.service$ sudo apt install phpmyadmin 安装过程中一切选项保持默认即可。下一步，将PHPMyAdmin的安装目录连接到网页目录1234# 设置软连接$ sudo ln -s /usr/share/phpmyadmin /var/www/html/pma# 重启Apache$ sudo /etc/init.d/apache2 restart 此时访问 http://你的地址或域名/pma ,你将进入到phpmyadmin的登录页面。但使用root账号无法登录。下一步我们将配置一个用于登录phpmyadmin的mysql账号：12345678910# 进入MySQL$ mysql# 切换数据库mysql&gt; use mysql# 创建一个用户,用户名为test,密码为1234mysql&gt; insert into mysql.user(Host,User,Password) values(\"%\",\"test\",password(\"1234\"));# 为该用户授予所有权限，注意密码要一致mysql&gt; grant all privileges on *.* to test@% identified by '1234';# 刷新权限mysql&gt; flush privileges; 此时再打开PhpMyAdmin的页面，你就可以通过刚才创建的用户登录并管理数据库了。 至此，小型寝室网络服务器的基本环境搭建完成。 感谢阅读 author:AZ","link":"/2019/05/17/third/"},{"title":"代码简洁之道","text":"测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。 本文并不是代码风格指南，而是关于代码的可读性、复用性、扩展性探讨。 我们将从几个方面展开讨论： 变量用有意义且常用的单词命名变量Bad：12int a = 1000;//这样用a、b、c等字母做变量名是一个很不好的习惯。 Good:12int nowCurrent = 1000;//nowCurrent变量名，一看就是用来定义“现在电流”的变量。 保持统一可能同一个项目对于获取不同的变量，会有三个不一样的命名。应该保持统一，如果你不知道该如何取名，可以去 codelf 搜索，看别人是怎么取名的。 Bad:1234get_p11_I();//获取P1^1的电流get_V_p22();//获取P2^2的电压 Good:12get_data_i()get_data_v() 每个常量都该命名Bad:12// 三个月之后你还能知道 50 是什么吗?能达到什么效果吗？set_pwm(50); Good:123int right_moto_go = 50;//这个变量名，几个月后一看还是可以知道是一个使“左轮前进”的变量所需的pwm。set_pwm(right_moto_go); 可描述通过一个变量生成了一个新变量，也需要为这个新变量命名，也就是说每个变量当你看到他第一眼你就知道他是干什么的。 Bad:12345678void run(int lv , int rv){ ...}//定义一个电机驱动函数//以下是错误实例//给左轮100、右轮0。使小车左轮。run(100,0); Good:123456789void run(int lv , int rv){ ...}//定义一个电机驱动函数//以下是正确示范。一眼就可以看出是是小车左转需要给左轮100的占空比，右轮0的占空比。int turn_left_lv = 100 , turn_right_lv = 0;run(turn_left_lv , turn_right_lv); 避免无意义的前缀如果创建了一个结构体 car，就没有必要把它的颜色命名为 carColor。 Bad:123456789struct car { char[] carMake, char[] carModel, char[] carColor}void paintCar(car) { car.carColor = 'Red';} Good:123456789struct car { char[] make, char[] model, char[] color}void paintCar(car) { car.color = 'Red';} 函数函数的命名很有讲究，在Java中一般采用驼峰命名法，而在c语言中一般常采用小写英文字母+”_”的命名规则。如：get_i_data()（获取电流数据）set_pwm()(设置pwm值)。 参数越少越好如果参数超过两个，在某种特殊的语言中，如 ES2015/ES6 的解构语法，不用考虑参数的顺序。 Bad:123function createMenu(title, body, buttonText, cancellable) { // ...} Good:12345678910function createMenu({ title, body, buttonText, cancellable }) { // ...}createMenu({ title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true}); 只做一件事这是一条在软件工程领域流传久远的规则。严格遵守这条规则会让你的代码可读性更好，也更容易重构。如果违反这个规则，那么代码会很难被测试或者重用。 Bad：12345void get_data(int *i , int *v){ *i = ....; *v = ....; //这个函数传入两个指针，即该函数实现了既能获取电流i、又实现了获取电压v的功能。} Good：1234567891011int get_i(){ int i; ... return i;}int get_v(){ int v; ... return v;} 顾名思意看函数名就应该知道它是干啥的。 Bad：1234567void addToData(int i){ ...}addtoData(500);//很难看出把500添加到什么数据里 Good:123456void add_i_to_data(int i){ ...}add_i_to_data(500);//一看可以看出将500添加到电流的数据里 删除重复代码很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数。 要想优化重复代码需要有较强的抽象能力，错误的抽象还不如重复代码。所以在抽象过程中必须要遵循 SOLID 原则（SOLID 是什么？稍后会详细介绍）。 不要传flag参数通过 flag 的 大小，来判断执行逻辑，违反了一个函数干一件事的原则。 Bad:123456int calculate(int i ,int j ,int flag){ if(flag == 1)return i+j; if(flag == 2)return i-j; .... } Good:1234567int add(int i , int j ){ return i+j;}int delete(int i , int j ){ return i-j;} 避免副作用函数接收一个值返回一个新值，除此之外的行为我们都称之为副作用，比如修改全局变量、对文件进行 IO 操作等。 当函数确实需要副作用时，比如对文件进行 IO 操作时，请不要用多个函数/类进行文件操作，有且仅用一个函数/类来处理。也就是说副作用需要在唯一的地方处理。 副作用的三大天坑：随意修改可变数据类型、随意分享没有数据结构的状态、没有在统一地方处理副作用。 Bad:1234567891011int i = 100;void add_i(){ i++;}int main(){ printf(\"%d\",i); add_i(); printf(\"%d\",i);} Good:123456789101112int i = 100;int add_i(){ return ++i;}int main(){ int j =0; printf(\"%d\",i); j = add_i(); printf(\"%d\",j);} 封装条件语句Bad:123if(i == 1 &amp;&amp; j &lt; 100 &amp;&amp; k &gt; 99){ ...} Good:12345678int check(int i, int j ,int k){ return (i == 1 &amp;&amp; j &lt; 100 &amp;&amp; k &gt; 99) ? 1:0;}if(check(i,j,k)){ ...} 尽量别用”非”条件句Bad:12345678int is_not_int(i){ ...}if(!is_not_int(1)){ ...} Good:12345678int is_int(i){ ...}if(is_int(1)){ ...} 删除弃用代码很多时候有些代码已经没有用了，但担心以后会用，舍不得删。 如果你忘了这件事，这些代码就永远存在那里了。 放心删吧，你可以在代码库历史版本中找他它。 bad:123//int old_get_i();//int old_get_i_update();int new_get_i(); Good:1int new_get_i(); 代码风格代码风格是主观的，争论哪种好哪种不好是在浪费生命。市面上有很多自动处理代码风格的工具，选一个喜欢就行了，我们来讨论几个非自动处理的部分。 常量大写Bad:12int target_i_mA = 70;//定义目标电流为70mA Good:1int TARGET_I_MA = 70; 注释只有业务逻辑需要注释代码注释不是越多越好。 Bad:123456789101112131415161718P1 = 0xFE;//点亮第一个LED灯delay(500);//延时500毫秒P1 = P1&gt;&gt;1;//循环点亮第二个灯。delay(500);//延时500毫秒P1 = P1&gt;&gt;1;//循环点亮第三个灯。delay(500);//延时500毫秒P1 = P1&gt;&gt;1;//循环点亮第四个灯。delay(500);//延时500毫秒P1 = P1&gt;&gt;1;//循环点亮第五个灯。 Good:12345678910//循环点亮五盏灯P1 = 0xFE;delay(500);P1 = P1&gt;&gt;1;delay(500);P1 = P1&gt;&gt;1;delay(500);P1 = P1&gt;&gt;1;delay(500);P1 = P1&gt;&gt;1; 删掉注释的代码Bad:123//int old_get_i();//int old_get_i_update();int new_get_i(); Good:1int new_get_i(); 不要有日记记住你有 git！ git log 可以帮你干这事。 Bad:12345/************** * 2019-05-01 实现流水灯 * 2019-05-02 实现数码管 * 2019-05-07 实现adc */ 感谢阅读 author:Reyunn","link":"/2019/05/14/second/"}],"tags":[{"name":"linux运维","slug":"linux运维","link":"/tags/linux运维/"},{"name":"代码规范","slug":"代码规范","link":"/tags/代码规范/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"网络编程","slug":"网络编程","link":"/tags/网络编程/"}],"categories":[{"name":"linux运维","slug":"linux运维","link":"/categories/linux运维/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"}]}